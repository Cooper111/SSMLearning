输出映射
ResultType:
输出简单类型:
根据用户名和性别统计一共有多少个这样的用户

输出HashMap:
将一条查询记录的字段名作为key, 字段值作为value, 进行输出
根据id查询用户

ResultType的小结:
只有当数据库中查询出来的字段名和pojo中的set方法的方法名的后面一部分相同,
才能够将该字段的值成功映射到该对象属性中. 如果不同则不能映射成功
如果查询出来的字段名和pojo中的set方法的方法名的后面一截没有一个相同的,
那么这个时候连对象都没有, 那么如何解决这个问题: 使用resultMap 来完成映射关系


ResultMap的使用:
根据id查询用户, 采用resultMap进行输出

动态SQL:
Mybatis中提供了where标签和if标签来进行SQL片段的拼接, 满足不同的需求
根据性别和姓名查询用户信息, 如果没有输入查询条件, 则查询所有信息

查询用户名中带"小"字, 性别为1, 用户id为28, 30的用户信息
QueryVo中多个id值封装一个ids集合属性用来传递


定义SQL片段:
将多条SQL中公共的部分抽取出来, 定义一个SQL片段,
然后可以在其它地方引入该SQL片段, 但是要注意, 如果引入的是
其它映射文件中的SQL片段, 那么在引入该SQL片段时, 在refid里面
需要输入命名空间+该SQL片段id, 中间用.连接


Mybatis的高级映射:
一对一映射:
查询订单信息, 并且关联查询该订单下对应的用户信息(用户姓名, 性别, 地址)

这个过程中, 存在着订单到用户一对一的关系
通过观察发现结果集中, 既有订单的信息, 也有用户的信息, 所以
用一个新的类封装所有的查询字段, 然后采用该类型作为输出类型.

使用ResultMap实现一对一映射
此时, 我们可以在Orders类直接对用户信息进行封装, 提供了一个User对象属性

一对多映射
分析订单表和订单明细表:
orderdetail(orders_id) -> 关联orders表(id)
orders(user_id) -> 关联`user`的(id)

orders --> orderdetail: 一对多的关系
orderdetail --> orders: 一对一的关系

查询订单信息并且关联用户信息和对应的订单明细的信息


多对多映射:
查询用户信息并且关联查询用户购买的商品的信息
通过查看表结构, 我们知道, 用户表和商品表在数据库的结构上面没有
任何直接关联

通过resultMap进行输出:
用户 -> 订单 (一对多)
订单 -> 订单明细 (一对多)
订单明细 -> 商品 (一对一)

实现过程:
1. 在User类中, 有一个List<Orders> ordersList;
2. 在Orders类中, 有一个List<Orderdetail> odlist;
3. 在Orderdetail类中, 有一个Items items;



延迟加载
缓存
Mybatis整合spring



















